['ATMIOC_AREQUIPA', '0xc0', '/* Application requested IP over ATM, glob. u. */']
['ATMIOC_BACKEND', '0x90', '/* ATM generic backend ioctls, u. per backend */']
['ATMIOC_BACKEND_END', '0xaf', '/* 0xb0-0xbf: Reserved for future use */']
['ATMIOC_CLIP', '0xe0', '/* Classical IP over ATM control, globally u. */']
['ATMIOC_CLIP_END', '0xef', '#']
['ATMIOC_ITF', '0x80', '/* Interface ioctls, globally unique */']
['ATMIOC_ITF_END', '0x8f', '#']
['ATMIOC_LANE', '0xd0', '/* LAN Emulation, globally unique */']
['ATMIOC_MPOA', '0xd8', '/* MPOA, globally unique */']
['ATMIOC_PHYCOM', '0x00', '/* PHY device common ioctls, globally unique */']
['ATMIOC_PHYCOM_END', '0x0f', '#']
['ATMIOC_PHYPRV', '0x30', '/* PHY dev private ioctls, unique per driver */']
['ATMIOC_PHYPRV_END', '0x4f', '#']
['ATMIOC_PHYTYP', '0x10', '/* PHY dev type ioctls, unique per PHY type */']
['ATMIOC_PHYTYP_END', '0x2f', '#']
['ATMIOC_SARCOM', '0x50', '/* SAR device common ioctls, globally unique */']
['ATMIOC_SARCOM_END', '0x50', '#']
['ATMIOC_SARPRV', '0x60', '/* SAR dev private ioctls, unique per driver */']
['ATMIOC_SARPRV_END', '0x7f', '#']
['ATMIOC_SPECIAL', '0xf0', '/* Special-purpose controls, globally unique */']
['ATMIOC_SPECIAL_END', '0xff', '#']
['BASE_VIDIOC_PRIVATE', '192', '/* 192-255 are private */']
['BTRFS_IOCTL_DEV_REPLACE_CMD_CANCEL', '2', '#']
['BTRFS_IOCTL_DEV_REPLACE_CMD_START', '0', '#']
['BTRFS_IOCTL_DEV_REPLACE_CMD_STATUS', '1', '#']
['BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_ALWAYS', '0', '#']
['BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_AVOID', '1', 'struct']
['BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED', '2', 'struct']
['BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED', '1', '#']
['BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR', '0', '#']
['BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED', '3', '#']
['BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED', '2', '#']
['BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED', '0', '#']
['BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED', '1', '#']
['BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED', '4', 'struct']
['BTRFS_IOCTL_MAGIC', '0x94', '#']
['CCISS_IOC_MAGIC', "'B'", 'typedef']
['CM_IOC_MAGIC', "'c'", '#']
['CM_IOC_MAXNR', '255', '#']
['COOKED_IOCTL', '1', '#']
['CUSE_UNRESTRICTED_IOCTL', '(', '1', '<<', '0', ')', '/**\n * Release flags\n */']
['C_CM_IOCTL', '0x02', '/* re-read CH_CTRL */']
['C_CM_IOCTLM', '0x04', '/* RS-232 outputs change */']
['C_CM_IOCTLW', '0x03', '/* re-read CH_CTRL, intr when done */']
['C_IN_IOCTLW', '0x00020000', '/* I/O control w/ wait */']
['DECNET_IOCTL_BASE', '0x89', '/* PROTOPRIVATE range */']
['DM_IOCTL', '0xfd', '#']
['DRM_IOCTL_BASE', "'d'", '#']
['DTV_IOCTL_MAX_MSGS', '64', 'struct']
['FSL_HV_IOCTL_TYPE', '0xAF', '/* Restart another partition */']
['FUSE_IOCTL_MAX_IOV', '256', '/**\n * Poll flags\n *\n * FUSE_POLL_SCHEDULE_NOTIFY: request poll notify\n */']
['GIGASET_IOCTL', '0x47', '/* enable/disable device control via character device (lock out ISDN subsys) */']
['GNUTLS_E_CRYPTODEV_IOCTL_ERROR', '-', '211', '#']
['IB_IOCTL_MAGIC', '0x1b', '#']
['IOCB_FLAG_RESFD', '(', '1', '<<', '0', ')', '/* read() from /dev/aio returns these structures. */']
['MGSL_MAGIC_IOC', "'m'", '#']
['MMC_IOC_MAX_BYTES', '(', '512L', '*', '256', ')', '#']
['MMTIMER_IOCTL_BASE', "'m'", '#']
['MTRR_IOCTL_BASE', "'M'", '/* Warning: this structure has a different order from i386\n   on x86-64. The 32bit emulation code takes care of that.\n   But you need to use this for 64bit, otherwise your X server\n   will break. */']
['PH_IOC_MAGIC', "'p'", '#']
['PP_IOCTL', "'p'", '/* Set mode for read/write (e.g. IEEE1284_MODE_EPP) */']
['RFKILL_IOC_MAGIC', "'R'", '#']
['RFKILL_IOC_NOINPUT', '1', '#']
['UBI_CTRL_IOC_MAGIC', "'o'", '/* Attach an MTD device */']
['UINPUT_IOCTL_BASE', "'U'", '#']
['USBTMC_IOC_NR', '91', '#']
['USB_SUBCLASS_AUDIOCONTROL', '0x01', '#']
['VIOCD_MAJOR', '113', '#']
['WATCHDOG_IOCTL_BASE', "'W'", 'struct']
['_ASM_GENERIC_IOCTL_H', "/* ioctl command encoding: 32 bits total, command in lower 16 bits,\n * size of the parameter structure in the lower 14 bits of the\n * upper 16 bits.\n * Encoding the size of the parameter structure in the ioctl request\n * is useful for catching programs compiled with old versions\n * and to avoid overwriting user space outside the user buffer area.\n * The highest 2 bits are reserved for indicating the ``access mode''.\n * NOTE: This limits the max parameter size to 16kB -1 !\n */"]
['_EVENT_HAVE_SYS_IOCTL_H', '1', '/* Define to 1 if you have the <sys/mman.h> header file. */']
['_IOC', '(', 'dir', ',', 'type', ',', 'nr', ',', 'size', ')', '(', '(', '(', 'dir', ')', '<<', '_IOC_DIRSHIFT', ')', '|', '(', '(', 'type', ')', '<<', '_IOC_TYPESHIFT', ')', '|', '(', '(', 'nr', ')', '<<', '_IOC_NRSHIFT', ')', '|', '(', '(', 'size', ')', '<<', '_IOC_SIZESHIFT', ')', ')', '#']
['_IOC_DIR', '(', 'nr', ')', '(', '(', '(', 'nr', ')', '>>', '_IOC_DIRSHIFT', ')', '&', '_IOC_DIRMASK', ')', '#']
['_IOC_DIRBITS', '2', '#']
['_IOC_DIRMASK', '(', '(', '1', '<<', '_IOC_DIRBITS', ')', '-', '1', ')', '#']
['_IOC_DIRSHIFT', '(', '_IOC_SIZESHIFT', '+', '_IOC_SIZEBITS', ')', '/*\n * Direction bits, which any architecture can choose to override\n * before including this file.\n */']
['_IOC_NONE', '0U', '#']
['_IOC_NR', '(', 'nr', ')', '(', '(', '(', 'nr', ')', '>>', '_IOC_NRSHIFT', ')', '&', '_IOC_NRMASK', ')', '#']
['_IOC_NRBITS', '8', '#']
['_IOC_NRMASK', '(', '(', '1', '<<', '_IOC_NRBITS', ')', '-', '1', ')', '#']
['_IOC_NRSHIFT', '0', '#']
['_IOC_READ', '2U', '#']
['_IOC_SIZE', '(', 'nr', ')', '(', '(', '(', 'nr', ')', '>>', '_IOC_SIZESHIFT', ')', '&', '_IOC_SIZEMASK', ')', '/* ...and for the drivers/sound files... */']
['_IOC_SIZEBITS', '14', '#']
['_IOC_SIZEMASK', '(', '(', '1', '<<', '_IOC_SIZEBITS', ')', '-', '1', ')', '#']
['_IOC_SIZESHIFT', '(', '_IOC_TYPESHIFT', '+', '_IOC_TYPEBITS', ')', '#']
['_IOC_TYPE', '(', 'nr', ')', '(', '(', '(', 'nr', ')', '>>', '_IOC_TYPESHIFT', ')', '&', '_IOC_TYPEMASK', ')', '#']
['_IOC_TYPEBITS', '8', '/*\n * Let any architecture override either of the following before\n * including this file.\n */']
['_IOC_TYPECHECK', '(', 't', ')', '(', 'sizeof', '(', 't', ')', ')', '/* used to create numbers */']
['_IOC_TYPEMASK', '(', '(', '1', '<<', '_IOC_TYPEBITS', ')', '-', '1', ')', '#']
['_IOC_TYPESHIFT', '(', '_IOC_NRSHIFT', '+', '_IOC_NRBITS', ')', '#']
['_IOC_WRITE', '1U', '#']
['_SIOC_DIR', '_IOC_DIR', '#']
['_SIOC_NONE', '_IOC_NONE', '#']
['_SIOC_READ', '_IOC_READ', '#']
['_SIOC_SIZE', '_IOC_SIZE', '#']
['_SIOC_WRITE', '_IOC_WRITE', '#']
['UBI_IOC_MAGIC', "'o'", '/* Create an UBI volume */']
['UBI_VOL_IOC_MAGIC', "'O'", "/* Start UBI volume update\n * Note: This actually takes a pointer (__s64*), but we can't change\n *       that without breaking the ABI on 32bit systems\n */"]
['IPMI_IOC_MAGIC', "'i'", '/* Messages sent to the interface are this format. */']
['PACKET_IOCTL_MAGIC', '(', "'X'", ')', '#']
['PCIIOC_BASE', '(', "'P'", '<<', '24', '|', "'C'", '<<', '16', '|', "'I'", '<<', '8', ')', '#']
['SNAPSHOT_IOC_MAGIC', "'3'", '#']
['SNAPSHOT_IOC_MAXNR', '20', '#']
['SIOC_IN', 'IOC_IN', '#']
['SIOC_INOUT', 'IOC_INOUT', '#']
['SIOC_OUT', 'IOC_OUT', '#']
['SIOC_VOID', 'IOC_VOID', '#']
['SPI_IOC_MAGIC', "'k'", "/**\n * struct spi_ioc_transfer - describes a single SPI transfer\n * @tx_buf: Holds pointer to userspace buffer with transmit data, or null.\n *\tIf no data is provided, zeroes are shifted out.\n * @rx_buf: Holds pointer to userspace buffer for receive data, or null.\n * @len: Length of tx and rx buffers, in bytes.\n * @speed_hz: Temporary override of the device's bitrate.\n * @bits_per_word: Temporary override of the device's wordsize.\n * @delay_usecs: If nonzero, how long to delay after the last bit transfer\n *\tbefore optionally deselecting the device before the next transfer.\n * @cs_change: True to deselect device before starting the next transfer.\n *\n * This structure is mapped directly to the kernel spi_transfer structure;\n * the fields have the same meanings, except of course that the pointers\n * are in a different address space (and may be of different sizes in some\n * cases, such as 32-bit i386 userspace over a 64-bit x86_64 kernel).\n * Zero-initialize the structure, including currently unused fields, to\n * accommodate potential future updates.\n *\n * SPI_IOC_MESSAGE gives userspace the equivalent of kernel spi_sync().\n * Pass it an array of related transfers, they'll execute together.\n * Each transfer may be half duplex (either direction) or full duplex.\n *\n *\tstruct spi_ioc_transfer mesg[4];\n *\t...\n *\tstatus = ioctl(fd, SPI_IOC_MESSAGE(4), mesg);\n *\n * So for example one transfer might send a nine bit command (right aligned\n * in a 16-bit word), the next could read a block of 8-bit data before\n * terminating that command by temporarily deselecting the chip; the next\n * could send a different nine bit command (re-selecting the chip), and the\n * last transfer might write some register values.\n */"]
['CZIOC', '(', "'M'", '<<', '8', ')', '#']
['IOC_IN', '(', '_IOC_WRITE', '<<', '_IOC_DIRSHIFT', ')', '#']
['IOC_INOUT', '(', '(', '_IOC_WRITE', '|', '_IOC_READ', ')', '<<', '_IOC_DIRSHIFT', ')', '#']
['IOC_OUT', '(', '_IOC_READ', '<<', '_IOC_DIRSHIFT', ')', '#']
